	public static boolean ConditionalOperator1() {
		// example, where operand stack is not empty at end of node
		int mark;
		boolean bRes;
		boolean a = false, b = true, c = false;
		mark = 101;
		bRes = a ? b : c;
		mark = 102;
		bRes = a ? (b ? c : a) : (c ? a : b);
		mark = 103;
		return bRes;
	}

public static boolean ConditionalOperator1()
	//nofStackSlots=1, nofLocalSlots=5, codeLen=57
		  0 iconst_0
		  1 istore_2 [a]
		  2 iconst_1
		  3 istore_3 [b]
		  4 iconst_0
		  5 istore [c]
		  7 bipush 101
		  9 istore_0 [mark]
		 10 iload_2 [a]
		 11 ifeq 18
		 14 iload_3 [b]
		 15 goto 20
		 18 iload [c]
		 20 istore_1 [bRes]
		 21 bipush 102
		 23 istore_0 [mark]
		 24 iload_2 [a]
		 25 ifeq 41
		 28 iload_3 [b]
		 29 ifeq 37
		 32 iload [c]
		 34 goto 51
		 37 iload_2 [a]
		 38 goto 51
		 41 iload [c]
		 43 ifeq 50
		 46 iload_2 [a]
		 47 goto 51
		 50 iload_3 [b]
		 51 istore_1 [bRes]
		 52 bipush 103
		 54 istore_0 [mark]
		 55 iload_1 [bRes]
		 56 ireturn

method ConditionalOperator1
	nodeNr:0 from 0 to 11	visited: false
		predecessor:
		successor: CFG-Node [14:15]	CFG-Node [18:18]
	nodeNr:1 from 14 to 15	visited: false
		predecessor: CFG-Node [0:11]
		successor: CFG-Node [20:25]
	nodeNr:2 from 18 to 18	visited: false
		predecessor: CFG-Node [0:11]
		successor: CFG-Node [20:25]
	nodeNr:3 from 20 to 25	visited: false
		predecessor: CFG-Node [14:15]	CFG-Node [18:18]
		successor: CFG-Node [28:29]	CFG-Node [41:43]
	nodeNr:4 from 28 to 29	visited: false
		predecessor: CFG-Node [20:25]
		successor: CFG-Node [32:34]	CFG-Node [37:38]
	nodeNr:5 from 32 to 34	visited: false
		predecessor: CFG-Node [28:29]
		successor: CFG-Node [51:56]
	nodeNr:6 from 37 to 38	visited: false
		predecessor: CFG-Node [28:29]
		successor: CFG-Node [51:56]
	nodeNr:7 from 41 to 43	visited: false
		predecessor: CFG-Node [20:25]
		successor: CFG-Node [46:47]	CFG-Node [50:50]
	nodeNr:8 from 46 to 47	visited: false
		predecessor: CFG-Node [41:43]
		successor: CFG-Node [51:56]
	nodeNr:9 from 50 to 50	visited: false
		predecessor: CFG-Node [41:43]
		successor: CFG-Node [51:56]
	nodeNr:10 from 51 to 56	visited: false
		predecessor: CFG-Node [32:34]	CFG-Node [37:38]	CFG-Node [46:47]	CFG-Node [50:50]
		successor:

SSA for Method: ConditionalOperator1
   SSANode 0:
      EntrySet {[ ], [ , , , , ]}
         0: NoOpnd[sCloadConst] 0 (Integer),   end=14, index=2, reg=29
         1: NoOpnd[sCloadConst] 1 (Integer),   end=14, index=3, reg=28
         2: NoOpnd[sCloadConst] 0 (Integer),   end=14, index=4, reg=27
         3: NoOpnd[sCloadConst] 101 (Integer),   end=3, index=0, reg=31
         4: Branch[sCBranch] {0} (Void)
      ExitSet {[ ], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 1:
      EntrySet {[ ], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}
         5: Monadic[sCRegMove] {1} (Integer),   end=-1, index=1, reg=30
         6: Branch[sCBranch]  (Void)
      ExitSet {[ 1 (Integer)], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 2:
      EntrySet {[ ], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}
         7: Monadic[sCRegMove] {2} (Integer),   end=-1, index=1, reg=30
      ExitSet {[ 2 (Integer)], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 3:
      EntrySet {[ 8 (Integer)], [ 3 (Integer), , 0 (Integer), 1 (Integer), 2 (Integer) ]}
         8: PhiFunction[sCPhiFunc] {1, 2} (Integer),   end=0, index=1, reg=30
         9: NoOpnd[sCloadConst] 102 (Integer),   end=7, index=0, reg=31
         10: Branch[sCBranch] {0} (Void)
      ExitSet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 4:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         11: Branch[sCBranch] {1} (Void)
      ExitSet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 5:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         12: Monadic[sCRegMove] {2} (Integer),   end=-1, index=1, reg=30
         13: Branch[sCBranch]  (Void)
      ExitSet {[ 2 (Integer)], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 6:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         14: Monadic[sCRegMove] {0} (Integer),   end=-1, index=1, reg=30
         15: Branch[sCBranch]  (Void)
      ExitSet {[ 0 (Integer)], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 7:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         16: Branch[sCBranch] {2} (Void)
      ExitSet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 8:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         17: Monadic[sCRegMove] {0} (Integer),   end=-1, index=1, reg=30
         18: Branch[sCBranch]  (Void)
      ExitSet {[ 0 (Integer)], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 9:
      EntrySet {[ ], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         19: Monadic[sCRegMove] {1} (Integer),   end=-1, index=1, reg=30
      ExitSet {[ 1 (Integer)], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}

   SSANode 10:
      EntrySet {[ 20 (Integer)], [ 9 (Integer), 8 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}
         20: PhiFunction[sCPhiFunc] {2, 0, 0, 1} (Integer),   end=16, index=1, reg=30
         21: NoOpnd[sCloadConst] 103 (Integer),   end=15, index=0, reg=31
         22: Branch[sCreturn] {20} (Void)
      ExitSet {[ ], [ 21 (Integer), 20 (Integer), 0 (Integer), 1 (Integer), 2 (Integer) ]}


Code for Method:ConditionalOperator1
	9421ffe0	[0x0]	stwu  r1, -32(r1)
	7c0802a6	[0x4]	mfspr  r0, LR
	90010020	[0x8]	stw  r0, 32(r1)
	bf610014	[0xc]	stmw  r27, 20(r1)
	3ba00000	[0x10]	li  r29, 0
	3b800001	[0x14]	li  r28, 1
	3b600000	[0x18]	li  r27, 0
	3be00065	[0x1c]	li  r31, 101
	2c1d0000	[0x20]	cmpi  crf0, 0, r29, 0
	419d000c	[0x24]	bc  iftrue, CRF0[EQ], 12, [0x30]	
	7f9ee378	[0x28]	lr  r30, r28
	48000008	[0x2c]	b  8, [0x34]	
	7f7edb78	[0x30]	lr  r30, r27
	3be00066	[0x34]	li  r31, 102
	2c1d0000	[0x38]	cmpi  crf0, 0, r29, 0
	419d001c	[0x3c]	bc  iftrue, CRF0[EQ], 28, [0x58]	
	2c1c0000	[0x40]	cmpi  crf0, 0, r28, 0
	419d000c	[0x44]	bc  iftrue, CRF0[EQ], 12, [0x50]	
	7f7edb78	[0x48]	lr  r30, r27
	48000020	[0x4c]	b  32, [0x6c]	
	7fbeeb78	[0x50]	lr  r30, r29
	48000018	[0x54]	b  24, [0x6c]	
	2c1b0000	[0x58]	cmpi  crf0, 0, r27, 0
	419d000c	[0x5c]	bc  iftrue, CRF0[EQ], 12, [0x68]	
	7fbeeb78	[0x60]	lr  r30, r29
	48000008	[0x64]	b  8, [0x6c]	
	7f9ee378	[0x68]	lr  r30, r28
	3be00067	[0x6c]	li  r31, 103
	7fc2f378	[0x70]	lr  r2, r30
	bb610014	[0x74]	lmw  r27, 20(r1)
	80010020	[0x78]	lwz  r0, 32(r1)
	7c0803a6	[0x7c]	mtspr  LR, r0
	38210020	[0x80]	addi  r1, r1, 32
	4e800020	[0x84]	bclr 20, 0

